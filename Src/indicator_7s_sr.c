/**************************************************************************************************
 * 		indicator_7s_sr.h
 *-------------------------------------------------------------------------------------------------
 * 		БИБЛИОТЕКА 7-СЕГМЕНТНОГО ИНДИКАТОРА
 *-------------------------------------------------------------------------------------------------
 *	Автор: Рогоза С.В.
 *	Дата: 26.04.23
 *************************************************************************************************/
#include <indicator_7s_sr.h>
//-------------------------------------------------------------------------------------------------
//	ФУНКЦИЯ ИНДИКАТОР СГД-4
//-------------------------------------------------------------------------------------------------
//	Функция обеспечивает работу 7-сегментного индикатора для изделия СГД-4, а также управляет
//	светодиодами индикации по интерфейсу SPI. В качестве драйвера светодиодов используется 74HC595.
//	Аргументы:
//		*spi_x - указатель на SPI (например, SPI1).
//		leds - однобайтовая переменная, в которой каждый бит отвечает за свечение одного из 8 LED.
//		*strn - указатель на строку, состоящую из 3 значащих символов, которая выводится на индик.
//		points - три первых бита отвечают за десятичные точки.
//	Возвращаемое значение: нет.
//-------------------------------------------------------------------------------------------------
void indicator_sgd4(SPI_TypeDef* spi_x, uint8_t leds, char *strn, uint8_t points)
{
	// Массив сегментов индикатора
	uint8_t digit[5];

	// Массив принятых символов
	uint8_t sym[] = {0, 0, 0, 0, 0};

	// Номер элемента строки
	uint8_t ns = 0;

	// Количество элементов массива
	uint8_t nd = 0;

	// Дешифратор символов
	while(ns < 4)
	{
		switch(*(strn + ns))
		{
			case'0': sym[ns] = 0b00111111; break;
			case'1': sym[ns] = 0b00000110; break;
			case'2': sym[ns] = 0b01011011; break;
			case'3': sym[ns] = 0b01001111; break;
			case'4': sym[ns] = 0b01100110; break;
			case'5': sym[ns] = 0b01101101; break;
			case'6': sym[ns] = 0b01111101; break;
			case'7': sym[ns] = 0b00000111; break;
			case'8': sym[ns] = 0b01111111; break;
			case'9': sym[ns] = 0b01101111; break;
			case' ': sym[ns] = 0b00000000; break;  // Пробел.

			case'A': sym[ns] = 0b01110111; break;
			case'b': sym[ns] = 0b01111100; break;
			case'C': sym[ns] = 0b00111001; break;
			case'd': sym[ns] = 0b01011110; break;
			case'E': sym[ns] = 0b01111001; break;
			case'F': sym[ns] = 0b01110001; break;
			case'G': sym[ns] = 0b00111101; break;
			case'H': sym[ns] = 0b01110110; break;
			case'I': sym[ns] = 0b00110000; break;
			case'J': sym[ns] = 0b00011110; break;
			case'L': sym[ns] = 0b00111000; break;
			case'O': sym[ns] = 0b00111111; break;
			case'P': sym[ns] = 0b01110011; break;
			case'S': sym[ns] = 0b01101101; break;
			case'X': sym[ns] = 0b01110110; break;
			case'U': sym[ns] = 0b00111110; break;
			case'Y': sym[ns] = 0b01101110; break;
			case'-': sym[ns] = 0b01000000; break;

			case'П': sym[ns] = 0b00110111; break;
			case'Р': sym[ns] = 0b01110011; break;
			case'Г': sym[ns] = 0b00110001; break;

			case'Н': sym[ns] = 0b01110110; break;
			case'В': sym[ns] = 0b01111111; break;
			case'С': sym[ns] = 0b00111001; break;
			case'Ч': sym[ns] = 0b01100110; break;


			// Если символ окончания строки, запоминается количество значащих символов в строке
			case'\0': nd = ns; break;

			// В случае неизвестного символа генерируется непонятный символ
			default: sym[ns] = 0b01000011;

		}//end switch

		// Если последний сивол не равен символу окончания строоки -
		// инкремент номера элемента строки
		if(*(strn + ns) != '\0') ns++;

		// Иначе - выход из цикла
		else break;

	}//end while

	switch(nd)
	{
		case 2:
		{
			sym[2] = sym[1];
			sym[1] = sym[0];
			sym[0] = 0;
		} break; //end case 2

		case 1:
		{
			sym[2] = sym[0];
			sym[1] = 0;
			sym[0] = 0;
		} break; //end case 1

		case 0:
		{
			sym[2] = 0;
			sym[1] = 0;
			sym[0] = 0;
		} break; //end case 1

		default:;
	}//end switch


	// Заполнение массива сегментов индикатора
	// Индексы соответствуют индексам позиционных обозначений на схеме
	digit[4] = leds;
	digit[3] = sym[0];
	digit[2] = sym[1];
	digit[1] = sym[2];

	// Добавление десятичных точек в соответствующие сегменты индикатора
	if(points & 0b100) digit[3] |= 0b10000000;
	if(points & 0b010) digit[2] |= 0b10000000;
	if(points & 0b001) digit[1] |= 0b10000000;

	// Передача данных в регистры
	for(uint8_t nn = 1; nn < 5; nn++)
	{
		// Передача в регистр данных элемента массива
		*(uint8_t *)&spi_x->DR = digit[nn];

		// Ожидание освобождения буфера
		while((spi_x->SR & SPI_SR_TXE) == 0);
	}//end for

	// Ожидание окончания передачи
	while((spi_x->SR & SPI_SR_BSY) > 0);




   	//////////////////
	// Выключение TIM17
	//TIM17->CR1 &= ~TIM_CR1_CEN;

	// Значение регистра автоматической перезагрузки
	TIM17->ARR = 10; // 10мс

	// Обнуление счетчика
	TIM17->CNT = 0;

	// Включение TIM17
	TIM17->CR1 |= TIM_CR1_CEN;

	// Разрешение прерывания от TIM17
    TIM17->DIER |= TIM_DIER_UIE;
   	//////////////////

    // PB9 = 1
    GPIOB->ODR |= GPIO_ODR_9;

}//end indicator_sgd4()
//-------------------------------------------------------------------------------------------------
